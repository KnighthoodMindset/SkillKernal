<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="description" content="Learn about Toward Efficient Parsing">
  <title>Software Testing | lecture 34 | SkillKernal</title>
  <link rel="stylesheet" href="exp.css" />
</head>
<body>
  <div class="top-banner">
    <h1>SkillKernal</h1>
    <h2>Your Core for Growth</h2>
  </div>

  <main>

    <section>
        <h3>Syntax based testing</h3>
    </section>
    <section>
      <p>Syntax-based testing focuses on designing test cases using the syntactical structure of software artifacts such as source code, design models, and input specifications. Every software artifact has an underlying syntax that defines how it should be written or represented. Programming languages, for instance, define valid constructs such as if statements, while loops, or function declarations, which must follow specific grammatical rules. These syntactical rules are often described using formal grammar representations. Syntax can also exist in modeling languages like UML diagrams or in data formats such as XML, which follow strict syntactical patterns. The goal of syntax-based testing is to exploit these syntactical structures to generate valid and invalid test cases, ensuring the software behaves correctly for all syntactically valid inputs and handles syntactically invalid inputs appropriately.
</p>
      <p>Programming languages define their syntax at three levels. The first is the lexical level, which deals with tokens or words formed from characters. This level is usually defined using regular expressions that specify how characters combine to form valid tokens like identifiers, numbers, or keywords. The second level is the phrase level, which defines how these tokens combine to form valid phrases or statements in the language, such as expressions or declarations. This level is defined using context-free grammars, often represented in Backus–Naur Form. The third level is the context-sensitive level, which defines rules involving meaning or context, such as ensuring a variable is declared before use or maintaining type consistency. While regular expressions and context-free grammars define the structural syntax of a language, context-sensitive grammars ensure semantic correctness. In syntax-based testing, the focus is mainly on the first two levels—regular expressions and context-free grammars—because these directly describe the structure that can be manipulated to generate test cases.
</p>
      <p>Regular expressions form the foundation of the lexical level and are used to describe regular languages. They are constructed from basic elements of an alphabet and operators such as union (+), concatenation (·), and Kleene star (*). The empty set, single letters, and their combinations using these operators form regular expressions. Each regular expression represents a set of strings known as a language. The union operator combines languages, concatenation appends strings from two languages, and the Kleene star represents zero or more repetitions of a language. For example, the regular expression (a* + b*)c represents all strings containing only a’s or only b’s followed by a c. Regular expressions are often represented as parse trees, where leaves denote alphabet symbols and internal nodes denote operations. The languages they define can be recognized by finite state automata, and the relationship between the two is captured by Kleene’s theorem, which states that every regular expression corresponds to a finite automaton and vice versa.
</p>
      <p>Context-free grammars, on the other hand, define the phrase-level syntax of programming languages. A context-free grammar consists of a finite set of non-terminal symbols, terminal symbols, a start symbol, and production rules. Each production rule replaces a single non-terminal with a combination of terminals and non-terminals. The grammar generates strings by starting from the start symbol and repeatedly applying production rules until only terminals remain. The collection of all such strings forms the language generated by the grammar. For example, a simple grammar with rules S → aX and X → aX | bX | ab generates all strings beginning with ‘a’ and ending with ‘b’. Grammars of this form are called context-free because the replacement of a non-terminal does not depend on its surrounding context. Context-free grammars are widely used to define programming languages and data description formats. In testing, they can be used to generate valid and invalid strings to test parsers, compilers, or software components that process structured inputs.
</p>
      <p>Coverage criteria for syntax-based testing include terminal symbol coverage, production coverage, and derivation coverage. Terminal symbol coverage ensures that every terminal in the grammar appears in at least one generated test case. Production coverage ensures that each production rule in the grammar is used at least once in generating test cases, making it a stronger criterion since covering all productions implies covering all terminals. Derivation coverage aims to include all possible strings derivable from the grammar, but this is often infeasible because grammars can generate infinite languages due to recursive rules. In practice, testers use the first two criteria to achieve meaningful coverage without redundancy or infeasibility. Syntax-based testing helps verify that software components correctly handle valid inputs as defined by the grammar and reject invalid ones, thus improving robustness and reliability.
</p>
    </section>

          
  </main>

    <footer>
    <a href="ST_l34_Quiz.html" class="back-btn">Attempt Quiz</a>
    </footer>

 </body>
</html>