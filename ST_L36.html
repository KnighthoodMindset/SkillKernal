<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="description" content="Learn about Toward Efficient Parsing">
  <title>Software Testing | lecture 36 | SkillKernal</title>
  <link rel="stylesheet" href="exp.css" />
</head>
<body>
  <div class="top-banner">
    <h1>SkillKernal</h1>
    <h2>Your Core for Growth</h2>
  </div>

  <main>

    <section>
        <h3>Mutation testing for  programs</h3>
    </section>
    <section>
      <p>Mutation testing is a method used to evaluate the quality of test cases by deliberately introducing small changes or faults into a program and observing whether the existing test cases can detect these changes. The original version of the program is called the ground string, and each modified version is referred to as a mutant. A mutation operator defines the kind of change introduced, such as altering a variable, relational operator, or expression. In program-based mutation testing, these operators are applied to the source code to generate mutants that still compile and execute correctly. The primary objective is to check whether the test cases can distinguish between the behavior of the original and mutated programs. When a test case produces different outputs for the two versions, the mutant is said to be killed; otherwise, it survives, indicating that the test suite is not effective enough.
</p>
      <p>To illustrate this, consider a program that finds the minimum of two integers. The ground string initializes a variable minVal with the value of a, compares a and b, and assigns the smaller value to minVal. From this program, different mutants can be generated by making small syntactic changes. For example, one mutant may replace minVal = a with minVal = b, another may alter the condition if (b < a) to if (b > a), and others may modify variables or operators in various ways. Each mutant represents a single, independent modification, and the task of the tester is to design test cases that can detect these changes. Mutants are often labeled (such as delta1, delta2, etc.) to identify the specific mutation applied. Some mutants replace variable references, some alter relational operators, and some introduce runtime failure statements or special constructs like fail-on-zero, which help test how a program behaves when inputs take extreme or unexpected values.
</p>
      <p>Mutants are classified based on their characteristics. A stillborn mutant is one that results in an invalid program that cannot be compiled and is therefore discarded. A trivial mutant can be easily killed by almost any test case and offers little value in assessing test quality. An equivalent mutant behaves identically to the original program for all inputs, making it impossible to kill. A dead mutant is a valid mutant that can be killed by some test case, and such mutants are valuable for evaluating test effectiveness. The process of killing a mutant can be analyzed using the concepts of reachability, infection, and propagation. A statement must be reachable in execution for the mutation to be tested; infection occurs when the mutation causes a change in the program’s internal state; and propagation ensures that this change affects the output so it can be observed.
</p>
      <p>Killing mutants can be categorized as strong or weak. In strong killing, the difference caused by the mutation propagates all the way to the program output, making the behavioral difference visible in the results. In weak killing, it is sufficient that the mutated statement causes a change in the program’s internal state, even if it does not affect the final output. Strong mutation coverage ensures that each mutant is strongly killed by at least one test case, while weak mutation coverage only requires detection of internal behavioral changes. For example, in the minVal program, providing inputs where b is greater than a ensures that the mutant which assigns minVal = b instead of minVal = a is killed because the outputs will differ. In other cases, as with a mutant that replaces a variable with an equivalent one, no test case can produce a different result, meaning the mutant is equivalent and cannot be killed.
</p>
      <p>The process of mutation testing begins with an input program called the ground string. Mutation operators are applied one at a time to generate different mutants. If a mutant is equivalent to the original program, it is discarded since it cannot be killed. Test cases are then generated and executed on both the original and mutated programs. If a test case causes different outputs, it successfully kills the mutant. If the outputs remain the same, the test case is ineffective, and additional test cases must be designed. The process continues until a predefined threshold of mutants has been tested. If errors are detected, the program is fixed and re-tested. Mutation testing is considered one of the most powerful techniques for assessing the thoroughness of test suites because it can subsume other coverage criteria. It is widely used for both unit and integration testing, though it is computationally intensive and requires careful selection of effective mutation operators and meaningful test cases.
</p>
    </section>
          
  </main>

    <footer>
    <a href="ST_l36_Quiz.html" class="back-btn">Attempt Quiz</a>
    </footer>

 </body>
</html>