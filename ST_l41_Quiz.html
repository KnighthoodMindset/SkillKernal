<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Software Testing - Quiz | SkillKernal</title>
  <link rel="stylesheet" href="Quiz.css"/>
</head>
<body>
  <!-- Header -->
  <header>
    <div class="logo">SK</div>
    <div>
      <h1>SkillKernal</h1>
      <p class="tagline">Your Core for Growth</p>
    </div>
  </header>

  <main class="quiz-container">
    <h2>Software testing - lecture 36 - Quiz</h2>
    <form id="quizForm">


<div class="question">
  <p>What are the two main categories of mutation testing?</p>
  <label><input type="radio" name="q1" value="a"> Unit testing and integration testing</label><br>
  <label><input type="radio" name="q1" value="b"> Grammar-based testing and program-based mutation testing</label><br>
  <label><input type="radio" name="q1" value="c"> Syntax testing and semantic testing</label><br>
  <label><input type="radio" name="q1" value="d"> White-box and black-box testing</label><br>
  <div class="answer" data-correct="b">Mutation testing can be categorized into grammar-based testing and program-based mutation testing.</div>
</div>

<div class="question">
  <p>Which type of mutation testing is applicable at all levels, including unit, design integration, and specification?</p>
  <label><input type="radio" name="q2" value="a"> Grammar-based testing</label><br>
  <label><input type="radio" name="q2" value="b"> Program-based mutation testing</label><br>
  <label><input type="radio" name="q2" value="c"> Structural testing</label><br>
  <label><input type="radio" name="q2" value="d"> Edge coverage testing</label><br>
  <div class="answer" data-correct="b">Program-based mutation testing can be applied at all levels, including unit, integration, and specification.</div>
</div>

<div class="question">
  <p>How are inputs with complex structure, such as banking transactions, typically described?</p>
  <label><input type="radio" name="q3" value="a"> Using natural language descriptions</label><br>
  <label><input type="radio" name="q3" value="b"> Using regular expressions or context-free grammars</label><br>
  <label><input type="radio" name="q3" value="c"> Using UML diagrams</label><br>
  <label><input type="radio" name="q3" value="d"> Using pseudocode only</label><br>
  <div class="answer" data-correct="b">Inputs with complex structure are described using formal languages like regular expressions or context-free grammars.</div>
</div>

<div class="question">
  <p>What role does a start symbol play in grammar-based test case generation?</p>
  <label><input type="radio" name="q4" value="a"> It determines the root element in XML only</label><br>
  <label><input type="radio" name="q4" value="b"> Test cases are derived by starting from the start symbol and applying production rules</label><br>
  <label><input type="radio" name="q4" value="c"> It defines the programming language syntax</label><br>
  <label><input type="radio" name="q4" value="d"> It represents terminal symbols only</label><br>
  <div class="answer" data-correct="b">Test cases are generated by starting from the designated start symbol and applying production rules until terminal strings are obtained.</div>
</div>

<div class="question">
  <p>Why is XML commonly used for input in web applications and services?</p>
  <label><input type="radio" name="q5" value="a"> It allows hierarchical nesting and follows a well-defined grammar</label><br>
  <label><input type="radio" name="q5" value="b"> It executes faster than other formats</label><br>
  <label><input type="radio" name="q5" value="c"> It requires no validation rules</label><br>
  <label><input type="radio" name="q5" value="d"> It replaces regular expressions in programs</label><br>
  <div class="answer" data-correct="a">XML allows hierarchical nesting of elements and is well-formed according to schemas, making it suitable for structured inputs.</div>
</div>

<div class="question">
  <p>What are some mutation operators used for input grammar testing?</p>
  <label><input type="radio" name="q6" value="a"> Non-terminal replacement, terminal replacement, deletion, duplication</label><br>
  <label><input type="radio" name="q6" value="b"> Statement insertion, operator replacement</label><br>
  <label><input type="radio" name="q6" value="c"> Predicate flipping and clause coverage</label><br>
  <label><input type="radio" name="q6" value="d"> Loop unrolling and branch inversion</label><br>
  <div class="answer" data-correct="a">Mutation operators for input grammars manipulate non-terminals, terminals, deletions, and duplications.</div>
</div>

<div class="question">
  <p>How do invalid inputs generated via grammar mutation help in testing?</p>
  <label><input type="radio" name="q7" value="a"> They increase program speed</label><br>
  <label><input type="radio" name="q7" value="b"> They assess error handling and reveal potential vulnerabilities</label><br>
  <label><input type="radio" name="q7" value="c"> They reduce the need for test cases</label><br>
  <label><input type="radio" name="q7" value="d"> They eliminate runtime exceptions</label><br>
  <div class="answer" data-correct="b">Invalid inputs help check program robustness, error handling, and uncover faults or vulnerabilities.</div>
</div>

<div class="question">
  <p>What is the difference between mutation testing for programs and input grammar mutation?</p>
  <label><input type="radio" name="q8" value="a"> Only programs require generating invalid inputs</label><br>
  <label><input type="radio" name="q8" value="b"> Program mutation requires additional test cases to kill mutants, whereas input mutation directly serves as test cases</label><br>
  <label><input type="radio" name="q8" value="c"> Input mutation cannot generate invalid cases</label><br>
  <label><input type="radio" name="q8" value="d"> Input mutation only works for Java programs</label><br>
  <div class="answer" data-correct="b">In program mutation, mutants need test cases to detect errors; in input grammar mutation, mutated inputs themselves are test cases.</div>
</div>

<div class="question">
  <p>How do XML schemas contribute to grammar-based mutation testing?</p>
  <label><input type="radio" name="q9" value="a"> They execute mutated inputs automatically</label><br>
  <label><input type="radio" name="q9" value="b"> They define precise grammar, structure, data types, and constraints for systematic test input generation</label><br>
  <label><input type="radio" name="q9" value="c"> They prevent invalid inputs completely</label><br>
  <label><input type="radio" name="q9" value="d"> They replace production rules in programs</label><br>
  <div class="answer" data-correct="b">XML schemas provide a formal grammar that allows testers to systematically generate valid and mutated test inputs.</div>
</div>

<div class="question">
  <p>Which of the following statements about mutation testing is true?</p>
  <label><input type="radio" name="q10" value="a"> It cannot be applied to input spaces</label><br>
  <label><input type="radio" name="q10" value="b"> It systematically explores errors and validates input handling</label><br>
  <label><input type="radio" name="q10" value="c"> It only works with unit testing</label><br>
  <label><input type="radio" name="q10" value="d"> It replaces all program testing</label><br>
  <div class="answer" data-correct="b">Mutation testing allows systematic exploration of errors, validation of input handling, and coverage of critical program behaviors.</div>
</div>

      
      
      <button type="submit" class="submit-btn">Submit Quiz</button>
    </form>

    <div id="result" class="result-box"></div>
  </main>

  <script src="quiz.js"></script>
</body>
</html>
